#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{amsthm}
\usepackage{amsfonts}

%\usepackage{hyperref}
%\hypersetup{hidelinks}

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{color}

\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Paper
\end_layout

\begin_layout Section
INTRODUCTION
\end_layout

\begin_layout Itemize
General importance of Stochastic Chemical Reaction Networks (SCRNs) and
 why they are necessary
\end_layout

\begin_layout Itemize
Mention SSA and other methods and their limitations (SDM, PPM, tau-leaping,
 ssSSA) [
\begin_inset Quotes eld
\end_inset

expert systems
\begin_inset Quotes erd
\end_inset

]
\end_layout

\begin_layout Itemize
Describe what multiscale networks are (multiscale in time and copy numbers)
\end_layout

\begin_layout Itemize
Argue about the importance of having tools for simulating such systems
\end_layout

\begin_layout Standard
In this paper we extend the known simulation methods for PDMP models to
 an adaptive scheme that incorporates multiple scales in both time and species
 copy-numbers and also takes advantage of the time-scale separation of subnetwor
ks with fast dynamics.
 The rest of this section formally introduces Stochastic Chemical Reaction
 Networks and Piecewise Deterministic Markov Processes.
 In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:MATHEMATICAL-OVERVIEW"

\end_inset

 we then recapitulate the existing theoretical foundation followed by the
 description of our implementation in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:IMPLEMENTATION"

\end_inset

.
 Thereafter we show numerical examples in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:NUMERICAL-EXAMPLES"

\end_inset

 and provide a discussion of our approach and conclusions in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:CONCLUSIONS"

\end_inset

.
\end_layout

\begin_layout Subsection*
Stochastic Chemical Reaction Network
\end_layout

\begin_layout Standard
A Stochastic Chemical Reaction Network (SCRN) with 
\begin_inset Formula $s_{0}$
\end_inset

 species given by 
\begin_inset Formula $x_{i}$
\end_inset

 with 
\begin_inset Formula $i=1,\ldots,s_{0}$
\end_inset

 and 
\begin_inset Formula $r_{0}$
\end_inset

 reactions is defined by
\end_layout

\begin_layout Itemize
the initial population 
\begin_inset Formula $x_{i}(0)$
\end_inset

 of each species 
\begin_inset Formula $i=1,\ldots,s_{0}$
\end_inset


\end_layout

\begin_layout Itemize
the reactions 
\begin_inset Formula $\sum_{i=1}^{s_{0}}\nu_{ik}x_{i}\longrightarrow\sum_{i=1}^{s_{0}}\nu'_{ik}x_{i}$
\end_inset

 for each reaction 
\begin_inset Formula $k=1,\ldots,r_{0}$
\end_inset

 (we define the stoichiometry vector as 
\begin_inset Formula $\xi_{k}=\nu'_{k}-\nu_{k}$
\end_inset

)
\end_layout

\begin_layout Itemize
the reaction propensities 
\begin_inset Formula $\lambda_{k}(x)$
\end_inset

 for each reaction 
\begin_inset Formula $k=1,\ldots,r_{0}$
\end_inset


\end_layout

\begin_layout Standard
The corresponding Markov Jump Process of the network in the random-time-change
 representation is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
X(t)=x(0)+\sum_{k=1}^{r_{0}}Y_{k}\left(\int_{0}^{t}\lambda_{k}\left(X(s)\right)ds\right)\left(\nu'_{k}-\nu_{k}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
where the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\{Y_{k}:\ k=1,\ldots,r_{0}\}$
\end_inset

 is a family of independent Poisson processes.
\end_layout

\begin_layout Standard
In this work we limit ourselves to the case of mass-action-kinetics with
 constitutive, unary and binary reactions.
 We can then write the propensities as
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lambda_{k}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reaction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\nu_{k}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\kappa'_{k}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\emptyset\rightarrow stuff$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\kappa'_{k}x_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{i}\rightarrow stuff$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{i}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\kappa'_{k}V^{-1}x_{i}x_{j}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{i}+S_{j}\rightarrow stuff$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{i}+e_{j}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\kappa'_{k}V^{-1}x_{i}(x_{i}-1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2S_{i}\rightarrow stuff$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2e_{i}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $V$
\end_inset

 corresponds to the volume of the system and the 
\begin_inset Formula $\kappa'_{k}$
\end_inset

 correspond to the molecular reaction rates.
\end_layout

\begin_layout Standard
Simulating a SCRN can become computationally expensive when the system is
 stiff (i.e.
 some reactions occur on a very small timescale, but are not important for
 the global behaviour) 
\begin_inset CommandInset citation
LatexCommand cite
key "rathinam2003stiffness"

\end_inset

.
 In such cases an approximation of the SCRN can provide considerable speedups
 in simulation time.
 One possibility for such an approximation is to split the fully stochastic
 system into a stochastic and a deterministic part which can be modeled
 as a Piecewise Deterministic Markov Process which is described in the following
 subsection.
 Another popular method for approximating SCRNs is 
\begin_inset Formula $\tau\textit{-leaping}$
\end_inset

 where multiple reactions are lumped into one simulation step by approximating
 the number of reactions with a poisson random variable 
\begin_inset CommandInset citation
LatexCommand cite
key "gillespie2001approximate"

\end_inset

.
\end_layout

\begin_layout Subsection*
Piecewise Deterministic Markov Processes
\end_layout

\begin_layout Standard
Here we give a short description of Piecewise Deterministic Markov Processes
 (PDMP) in the context of Stochastic Chemical Reaction Networks (SCRNs).
 We refer to 
\begin_inset CommandInset citation
LatexCommand cite
key "davis1984piecewise"

\end_inset

 for more details.
\end_layout

\begin_layout Standard
The state of a PDMP consists of a set of continuous and a set of discrete
 variables and both a vector field describing the dynamics of the continuous
 variables and a jump intensity function describing stochastic reactions.
 In the context of a SCRN the reactions 
\begin_inset Formula $1,\ldots,r_{0}$
\end_inset

 are also partitioned into two disjunct sets
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
M_{D}=\left\{ k:\ \mbox{reaction \ensuremath{k} is deterministic}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
M_{S}=\left\{ k:\ \mbox{reaction \ensuremath{k} is stochastic}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
and the species 
\begin_inset Formula $1,\ldots,s_{0}$
\end_inset

 are partitioned into two disjunct sets
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
S_{D}=\left\{ i:\ \mbox{species \ensuremath{i} is discrete}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
S_{C}=\left\{ i:\ \mbox{species \ensuremath{i} is continuous}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
where it has to be 
\begin_inset Formula $\nu'_{ik}=\nu_{ik}$
\end_inset

 for 
\begin_inset Formula $i\in S_{D}$
\end_inset

 and 
\begin_inset Formula $k\in M_{D}$
\end_inset

, i.e.
 discrete species can only be changed by stochastic reactions.
\end_layout

\begin_layout Standard
The vector field of the PDMP is then defined as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f:\ \mathbb{R}^{s_{0}}\rightarrow\mathbb{R}^{s_{0}},\ \frac{d}{dt}x_{i}(t)=f\left(x\right)=\sum_{k\in M_{D}}\lambda_{k}\left(x(t)\right)\left(\nu'_{ik}-\nu_{ik}\right)\mbox{ for \ensuremath{i\in S_{C}}}
\]

\end_inset


\end_layout

\begin_layout Standard
and the jump intensity function is defined as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Lambda_{k}\left(x\right)=\lambda_{k}\left(x\right)\mbox{ for \ensuremath{k\in M_{S}}}
\]

\end_inset


\end_layout

\begin_layout Standard
In the random-time-change representation the PDMP can be written as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
X(t)=x(0)+\sum_{k\in M_{D}}\int_{0}^{t}\lambda_{k}\left(X(s)\right)ds\left(\nu'_{k}-\nu_{k}\right)+\sum_{k\in M_{S}}Y_{k}\left(\int_{0}^{t}\lambda_{k}\left(X(s)\right)ds\right)\left(\nu'_{k}-\nu_{k}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
where the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\{Y_{k}:\ k\in M_{S}\}$
\end_inset

 is a family of independent Poisson processes.
\end_layout

\begin_layout Standard
One should note that the choice of a suitable partitioning is a non-trivial
 problem and for SCRNs with high variation over time there might not be
 a suitable partitioning.
 This is the motivation for introducing an adaptive scheme for approximating
 SCRNs.
\end_layout

\begin_layout Section
MATHEMATICAL OVERVIEW
\begin_inset CommandInset label
LatexCommand label
name "sec:MATHEMATICAL-OVERVIEW"

\end_inset


\end_layout

\begin_layout Standard
In this section we summarize existing theoretical results concerning stochastic
 models and SCRNs.
 We start by recapitulating the multiscale framework described by Kang et
 al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "kang2013"

\end_inset

 followed by a short summary concerning averaging of fast subnetworks.
\end_layout

\begin_layout Subsection*
Multiscale SCRNs
\end_layout

\begin_layout Standard
Kang et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "kang2013"

\end_inset

 describe a framework for separating both time-scales and copy-number-scales
 in SCRNs with mass action kinetics.
 To this end they define scaling parameters 
\begin_inset Formula $\alpha_{i}\geq0$
\end_inset

 for 
\begin_inset Formula $i=1,\ldots,s_{0}$
\end_inset

, 
\begin_inset Formula $\beta_{k}$
\end_inset

 for 
\begin_inset Formula $k=1,\ldots,r_{0}$
\end_inset

 and a large parameter 
\begin_inset Formula $N_{0}$
\end_inset

 and embed the original process 
\begin_inset Formula $X(t)$
\end_inset

 into a family of processes parameterized by 
\begin_inset Formula $N$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
X_{i}^{N}(t)=\left(\frac{N}{N_{0}}\right)^{\alpha_{i}}X_{i}(t)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Z_{i}^{N}(t)=N^{-\alpha_{i}}X_{i}^{N}(t)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\kappa_{k}=\begin{cases}
N^{-\beta_{k}}\kappa'_{k} & \mbox{for unary reactions}\\
N^{-\beta_{k}}\kappa'_{k}V^{-1} & \mbox{for binary reactions}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
The propensities for the parametrized process can now be written as
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reaction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Propensity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\lambda_{k}^{N}(z)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\emptyset\rightarrow\mbox{stuff}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N^{\beta_{k}}\lambda_{k}^{N}(z)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\kappa_{k}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{i}\rightarrow\mbox{stuff}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N^{\beta_{k}+\alpha_{i}}\lambda_{k}^{N}(z)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\kappa_{k}z_{i}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{i}+S_{j}\rightarrow\mbox{stuff}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N^{\beta_{k}+\alpha_{i}+\alpha_{j}}\lambda_{k}^{N}(z)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\kappa_{k}z_{i}z_{j}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2S_{i}\rightarrow\mbox{stuff}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N^{\beta_{k}+2\alpha_{i}}\lambda_{k}^{N}(z)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\kappa_{k}z_{i}(z_{i}-N^{-\alpha_{i}})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
With these definitions the markov process of the SCRN can be written as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Z_{i}^{N}(t)=Z_{i}^{N}(0)+N^{-\alpha_{i}}\sum_{k=1}^{r_{0}}Y_{k}\left(\int_{0}^{t}N^{\beta_{k}+\alpha\cdot\nu_{k}}\lambda_{k}^{N}\left(Z^{N}(s)\right)ds\right)\left(\nu'_{ik}-\nu_{ik}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\alpha\cdot\nu_{k}$
\end_inset

 denotes the dot product of vectors 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\nu_{k}$
\end_inset

.
\end_layout

\begin_layout Standard
In the limit 
\begin_inset Formula $N\rightarrow\infty$
\end_inset

 this process could explode if the exponent 
\begin_inset Formula $-\alpha_{i}$
\end_inset

 outside of the Poisson processes doesn't cancel the exponents 
\begin_inset Formula $\beta_{k}+\alpha\cdot\nu_{k}$
\end_inset

 inside of the Poisson processes.
 To make sure that the process is well-behaved for 
\begin_inset Formula $N\rightarrow\infty$
\end_inset

 the constraint 
\begin_inset Formula $\alpha_{i}\geq\beta_{k}+\alpha\cdot\nu_{k}$
\end_inset

 for 
\begin_inset Formula $i=1,\ldots,s_{0}$
\end_inset

, the so called the 
\shape italic
species balance condition
\shape default
, is introduced.
\end_layout

\begin_layout Standard
If the 
\shape italic
species balance condition
\shape default
 is satisfied, Kang et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "kang2013"

\end_inset

 show that the process 
\begin_inset Formula $Z_{i}^{N}(t)$
\end_inset

 converges to a PDMP in the limit 
\begin_inset Formula $N\rightarrow\infty$
\end_inset

.
 Thereby each reaction term
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
N^{-\alpha_{i}}Y_{k}\left(\int_{0}^{t}N^{\beta_{k}+\alpha\cdot\nu_{k}}\lambda_{k}^{N}\left(Z^{N}(s)\right)ds\right)\left(\nu'_{ik}-\nu_{ik}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
converges to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{cases}
0 & \mbox{if }\alpha_{i}>\beta_{k}+\alpha\cdot\nu_{k}\\
Y_{k}\left(\int_{0}^{t}\lambda_{k}^{\infty}\left(Z(s)\right)ds\right)\left(\nu'_{ik}-\nu_{ik}\right) & \mbox{if }\alpha_{i}=\beta_{k}+\alpha\cdot\nu_{k}=0\\
\left(\int_{0}^{t}\lambda_{k}^{\infty}\left(Z(s)\right)ds\right)\left(\nu'_{ik}-\nu_{ik}\right) & \mbox{if }\alpha_{i}=\beta_{k}+\alpha\cdot\nu_{k}>0
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\lambda_{k}^{\infty}(z)=\begin{cases}
\kappa_{k} & \mbox{for constitutive reactions}\\
\kappa_{k}z_{i} & \mbox{for unary reactions of species \ensuremath{i}}\\
\kappa_{k}z_{i}z_{j} & \mbox{for binary reactions of species \ensuremath{i}and \ensuremath{j}}
\end{cases}$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $N_{0}$
\end_inset

 is a large enough number then we expect a similar behaviour for the original
 process 
\begin_inset Formula $X_{i}(t)=N_{0}^{\alpha_{i}}Z_{i}^{N_{0}}$
\end_inset

.
 Intuitivly this allows us to approximate species with high copy numbers
 with deterministic dynamics as the fluctuations become less important.
\end_layout

\begin_layout Standard
Note: If the above constraints are not fulfilled Kang et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "kang2013"

\end_inset

 introduce other constraints for which the process  still converges to a
 PDMP.
\end_layout

\begin_layout Standard
So far the above convergence result gives us an approximation of the original
 process depending on the copy-number-scales.
 Another separation can occur on the time-scales: A subnetwork with dynamics
 which are much faster than the dynamics of the surrounding network will
 reach it's stationary average (provided that a stationary distribution
 exists) before influencing the surrounding network.
 Such a subnetwork can then be collapsed to it's stationary average 
\begin_inset CommandInset citation
LatexCommand cite
key "radulescu2008robust,crudu2012convergence"

\end_inset

.
 This is called averaging and is described in the following subsection.
\end_layout

\begin_layout Subsection*
Averaging of fast subnetworks
\end_layout

\begin_layout Standard
Given a subnetwork with 
\shape italic
fast
\shape default
 dynamics compared to the surrounding network (i.e.
 the species that are directly influenced by the subnetwork) we partition
 the reactions that are involved in the subnetwork into two sets, one that
 is only influencing the subnetwork, and the other one that is connecting
 the subnetwork to the surrounding network.
 We will then define a timescale for both of these sets of reactions so
 that we can define a formal criterion to check whether the subnetwork has
 
\shape italic
fast
\shape default
 dynamics.
 The final step is then to compute the stationary distribution of the subnetwork.
\end_layout

\begin_layout Standard
Following is a more formal description of the averaging and an elaboration
 on three different strategies for the computation of the stationary distributio
n of a subnetwork.
\end_layout

\begin_layout Subsubsection*
Formal description
\end_layout

\begin_layout Standard
Consider a SCRN with 
\begin_inset Formula $s_{0}$
\end_inset

 species and 
\begin_inset Formula $r_{0}$
\end_inset

 reactions.
 The general idea is to identify subnetworks of 
\shape italic
fast 
\shape default
species and average the state of those subnetworks according to the stationary
 distribution.
 Formally, given a subset of species 
\begin_inset Formula $Q=\left\{ q_{1},\ldots,q_{m}\right\} $
\end_inset

 we identify the set of reactions involving species from 
\begin_inset Formula $Q$
\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
R\left(Q\right)=\left\{ k:\ k\in\left\{ 1,\ldots,r_{0}\right\} \mbox{ and }\exists\ i\in Q:\ \nu_{ik}\neq\nu'_{ik}\right\} 
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{red}
\end_layout

\end_inset


\begin_inset Formula 
\[
R\left(Q\right)=\{k|\ \max\left(\nu_{ik},\nu'_{ik}\right)\neq0\mbox{ for }i\in Q\}
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{black}
\end_layout

\end_inset


\end_layout

\end_inset

Based on this, we define a partition of 
\begin_inset Formula $R\left(Q\right)$
\end_inset

 into two subsets of reactions 
\begin_inset Formula $R_{S}\left(Q\right)\subseteq R\left(Q\right)$
\end_inset

 and 
\begin_inset Formula $R_{B}\left(Q\right)\subseteq R\left(Q\right)$
\end_inset

.
 
\begin_inset Formula $R_{S}\left(Q\right)$
\end_inset

 includes those reactions that only change copy numbers of species in 
\begin_inset Formula $Q$
\end_inset

 whereas 
\begin_inset Formula $R_{B}\left(Q\right)$
\end_inset

 includes those reactions that change copy numbers of species not in 
\begin_inset Formula $Q$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
R_{S}\left(Q\right)=\left\{ k:\ k\in R\left(Q\right)\mbox{ and }v_{jk}=\nu'_{jk}\forall j\not\in Q\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
R_{B}\left(Q\right)=\left\{ k:\ k\in R\left(Q\right)\mbox{ and }\exists\ j\not\in Q:\ v_{jk}=\nu'_{jk}\right\} 
\]

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{red}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
R_{s}\left(Q\right)=\{k|\ \max\left(\nu_{ik},\nu'_{ik}\right)\neq0,\nu_{jk}=\nu'_{jk}\mbox{ for }i\in Q\mbox{ and }j\not\in Q\}
\]

\end_inset


\end_layout

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
R_{B}\left(Q\right)=\{k|\ \max\left(\nu_{ik},\nu'_{ik}\right)\neq0,\nu_{jk}\neq\nu'_{jk}\mbox{ for }i\in Q\mbox{ and }j\not\in Q\}
\]

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{black}
\end_layout

\end_inset


\end_layout

\end_inset


\lang english
We assume that the SCRN defined by 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $R\left(Q\right)$
\end_inset

 has a stationary distribution given the current state of the surrounding
 network.
\end_layout

\begin_layout Standard
We define the timescale separation of the subnetwork given by the species
 
\begin_inset Formula $Q$
\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Delta\tau\left(Q\right)=\min_{k\in R_{B}}\left(\tau_{B}\left(k\right)\right)-\max_{k\in R_{S}}\left(\tau_{S}\left(k\right)\right)
\]

\end_inset


\end_layout

\begin_layout Standard
where we define the logarithmic timescales 
\begin_inset Formula $\tau_{S}\left(k\right)$
\end_inset

 and 
\begin_inset Formula $\tau_{B}\left(k\right)$
\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{green}
\end_layout

\end_inset


\begin_inset Formula 
\[
\tau\left(k\right)=-\frac{\log\ \kappa'_{k}}{\log\ N}-\frac{1}{\log\ N}\sum_{i,\nu_{ik}\neq0}\begin{cases}
\log\ x_{i} & x>0\\
0 & x=0
\end{cases}+\min_{\left\{ i:\ \nu_{ik}\neq\nu'_{ik}\right\} }\left(\alpha_{i}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{black}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\tau_{S}\left(k\right)=-\frac{\log\ \kappa'_{k}}{\log\ N}-\frac{1}{\log\ N}\sum_{i,\nu_{ik}\neq0}\begin{cases}
\log\ x_{i} & x>0\\
0 & x=0
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\tau_{B}\left(k\right)=\tau_{S}\left(k\right)+\min_{\left\{ i:\ \nu_{ik}\neq\nu'_{ik}\right\} }\left(\alpha_{i}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
In words, 
\begin_inset Formula $\Delta\tau\left(Q\right)$
\end_inset

 is the minimum timescale of all reactions connecting the subnetwork to
 the outer network minus the maximum timescale of all reactions within the
 subnetwork.
 The second term (
\begin_inset Formula $\min_{\left\{ i:\ \nu_{ik}\neq\nu'_{ik}\right\} }\left(\alpha_{i}\right)$
\end_inset

) of 
\begin_inset Formula $\tau_{B}\left(k\right)$
\end_inset

 reflects the fact, that the relative change of a highly abundant species
 is smaller than the relative change of a low abundant species even if the
 reaction propensities are the same.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\Delta\tau\left(Q\right)\geq\zeta$
\end_inset

 where the parameter 
\begin_inset Formula $\zeta>0$
\end_inset

 then we can average the subset of species 
\begin_inset Formula $Q$
\end_inset

, i.e.
 set their copy number to their stationary average.
 Of course the results for the species in 
\begin_inset Formula $Q$
\end_inset

 can only be interpreted on the level of distributions and not on the level
 of single sample paths as those get lost in the process of averaging.
 Following we present three different strategies for averaging of fast subnetwor
ks:
\end_layout

\begin_layout Paragraph*
Finite Markov Chains
\end_layout

\begin_layout Standard
Consider a subset of fast species 
\begin_inset Formula $Q$
\end_inset

 fulfiling a conservation relation
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\sum_{q_{i}\in Q}a_{i}q_{i}=const.
\]

\end_inset

with 
\begin_inset Formula $a_{i}\in\mathbb{Z}_{\geq1}$
\end_inset

.
 Such a subnetwork forms a Finite Markov Chain (citation).
 Consider that the subnetwork is also irreducible, i.e.
 every state of the Markov Chain can be reached from any other state in
 finite time.
 Without loss of generality we enumerate the states with 
\begin_inset Formula $1,\ldots,L$
\end_inset

.
 The irreducibility of this Markov Chain is equivalent to 
\begin_inset Formula $\mbox{dim}\left(\mbox{null}\left(A\right)\right)=1$
\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 is the generator matrix of the Markov Chain.
 In the irreducible case the stationary distribution 
\begin_inset Formula $\pi_{1},\cdots,\pi_{L}$
\end_inset

 of the Markov Chain is an eigenvector of the generator matrix with eigenvalue
 
\begin_inset Formula $0$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
A^{T}\cdot\left[\begin{array}{c}
\pi_{1}\\
\vdots\\
\pi_{L}
\end{array}\right]=0
\]

\end_inset


\end_layout

\begin_layout Standard
Thus we can compute 
\begin_inset Formula $\pi_{1},\cdots,\pi_{L}$
\end_inset

 and perform averaging.
\end_layout

\begin_layout Paragraph*
Pseudo-Linear subnetworks
\end_layout

\begin_layout Standard
Consider a subset of fast species 
\begin_inset Formula $Q$
\end_inset

 such that all the reactions consuming or producing species in 
\begin_inset Formula $Q$
\end_inset

 have at most one reactant in 
\begin_inset Formula $Q$
\end_inset

.
 Such a subnetwork is called pseudo-linear as the additional reactants outside
 of the subnetwork can be considered constant for the timescale of the subnetwor
k.
 For linear SCRNs we can easily compute the stationary average by finding
 the stationary solution 
\begin_inset Formula $\frac{d}{dt}x_{i}\left(t\right)=0$
\end_inset

 of the corresponding deterministic system
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{d}{dt}x_{i}\left(t\right)=N^{-\alpha_{i}}\sum_{k=1}^{r_{0}}\int_{0}^{t}\left(N^{\beta_{k}+\alpha\cdot\nu_{k}}\lambda_{k}^{N}\left(Z^{N}(s)\right)ds\left(\nu'_{ik}-\nu_{ik}\right)\right)
\]

\end_inset


\end_layout

\begin_layout Standard
and thus we can perform averaging.
 Note: The stationary distribution on the other hand can't be easily computed
 for all linear SCRNs.
 We will elaborate on this in the next section.
\end_layout

\begin_layout Paragraph*
Zero-Deficiency subnetworks
\end_layout

\begin_layout Standard
Here we apply results from Anderson et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "anderson_kurtz_2010"

\end_inset

 showing that a 
\shape italic
weakly reversible
\shape default
 SCRN with 
\shape italic
deficiency
\shape default
 
\begin_inset Formula $0$
\end_inset

 has a unique stationary distribution 
\begin_inset Formula $\pi\left(x\right)$
\end_inset

 which is a product-form:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{cases}
\pi\left(x\right)=\prod_{i=1}^{s_{0}}\frac{c_{i}^{x_{i}}}{x_{i}!} & \mbox{ for reducible networks}\\
\pi\left(x\right)=\prod_{i=1}^{s_{0}}\frac{c_{i}^{x_{i}}}{x_{i}!}\exp\left(-c_{i}\right) & \mbox{ for irreducible networks}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $c\in\mathbb{R}_{\geq0}^{s_{0}}$
\end_inset

 is the equilibrium point of the corresponding deterministic system.
\end_layout

\begin_layout Standard
A SCRN is called 
\shape italic
weakly reversible
\shape default
 if for every reaction 
\begin_inset Formula $k$
\end_inset

 there is a sequence of reactions 
\begin_inset Formula $\nu_{k_{1}}\rightarrow\nu'_{k_{1}}\rightarrow\cdots\rightarrow\nu_{k_{m}}\rightarrow\nu'_{k_{m}}$
\end_inset

 such that 
\begin_inset Formula $\nu'_{k}=\nu_{k_{1}}$
\end_inset

 and 
\begin_inset Formula $\nu_{k}=\nu'_{k_{m}}$
\end_inset

.
 The 
\shape italic
deficiency
\shape default
 of a SCRN is defined as 
\begin_inset Formula $\delta=|C|-l-s$
\end_inset

 where 
\begin_inset Formula $|C|$
\end_inset

 is the number of reaction complexes (
\begin_inset Formula $C=\{\nu_{k}\}\cap\{\nu'_{k}\}$
\end_inset

), 
\begin_inset Formula $l$
\end_inset

 is the number of linkage classes (a linkage class is a connected component
 of the reaction complex graph corresponding to the SCRN) and 
\begin_inset Formula $s$
\end_inset

 is the dimension of the stoichiometric subspace 
\begin_inset Formula $S=span_{k\in\left\{ 1,\ldots,r_{0}\right\} }\left\{ \nu'_{k}-\nu_{k}\right\} $
\end_inset

.
 We refer to 
\begin_inset CommandInset citation
LatexCommand cite
key "anderson_kurtz_2010"

\end_inset

 for more details.
\end_layout

\begin_layout Standard
We will got into more details about the implementation in the following
 section.
\end_layout

\begin_layout Section
IMPLEMENTATION
\begin_inset CommandInset label
LatexCommand label
name "sec:IMPLEMENTATION"

\end_inset


\end_layout

\begin_layout Standard
In this section we shortly summarize the well known scheme for simulating
 a PDMP model and then describe our contribution of an adaptive hybrid scheme
 for simulating SCRNs.
\end_layout

\begin_layout Standard
We use the following notation for a specific sample path:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
initial time of simulation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
final time of simulation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
initial state of simulation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
total number of reactions occuring from 
\begin_inset Formula $t_{0}$
\end_inset

 until 
\begin_inset Formula $t_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t_{r}\left(p\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time of the 
\begin_inset Formula $p$
\end_inset

th reaction for 
\begin_inset Formula $p=1,\ldots,P$
\end_inset

 and by definition 
\begin_inset Formula $t_{r}\left(0\right)=t_{0}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $M_{S}\left(t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the set of reactions marked as stochastic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $M_{D}\left(t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the set of reactions marked as deterministic
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
Vanilla PDMP
\end_layout

\begin_layout Standard
The typical algorithm to simulate PDMP models is to evolve the part of the
 model that is described deterministically until the next stochastic reaction
 occurs.
 Then the copy numbers are updated according to the reaction.
 This is repeated until the end-timepoint of the simulation is reached.
\end_layout

\begin_layout Standard
The time of the next stochastic reaction 
\begin_inset Formula $p$
\end_inset

 is easily formulated as the root of an additional ODE state 
\begin_inset Formula $w_{p}$
\end_inset

 defined as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{d}{dt}w_{p}\left(t\right)=\sum_{k\in M_{S}}\lambda_{k}\left(x\left(t\right)\right)
\]

\end_inset


\end_layout

\begin_layout Standard
with the boundary condition of 
\begin_inset Formula $w_{p}\left(t_{r}\left(p-1\right)\right)=\log\left(u_{p}\right)$
\end_inset

 where 
\begin_inset Formula $u_{p}$
\end_inset

 is a random variable uniformly extracted from the interval 
\begin_inset Formula $[0,1]$
\end_inset

.
 Note that 
\begin_inset Formula $\log\left(u_{p}\right)\leq0$
\end_inset

 and 
\begin_inset Formula $\lambda_{k}\left(x\right)\geq0$
\end_inset

 and so starting from the time 
\begin_inset Formula $t=t_{r}\left(p-1\right)$
\end_inset

 the state 
\begin_inset Formula $w_{p}\left(t\right)$
\end_inset

 will monotonically increase until either 
\begin_inset Formula $t=t_{1}$
\end_inset

 if 
\begin_inset Formula $p=P$
\end_inset

 or if 
\begin_inset Formula $p<P$
\end_inset

 until the 
\begin_inset Formula $p$
\end_inset

th reaction occurs at 
\begin_inset Formula $t=t_{r}\left(p+1\right)$
\end_inset

.
 It follows from the random-time-change formulation that 
\begin_inset Formula $w_{p}\left(t_{r}\left(p+1\right)\right)=0$
\end_inset

.
 Thus by searching for the root of 
\begin_inset Formula $w_{p}\left(t\right)$
\end_inset

 one can find the time of the 
\begin_inset Formula $p$
\end_inset

th reaction in the process of solving the system of ODEs 
\begin_inset CommandInset citation
LatexCommand cite
key "kouretas2006stochastic"

\end_inset

.
 This is called root finding or event detection and modern ODE solvers like
 CVODE support this 
\begin_inset CommandInset citation
LatexCommand cite
key "serban2005cvodes"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{d}{dt}w\left(t\right)=\sum_{k\in M_{S}}\lambda_{k}\left(x\left(t\right)\right)
\]

\end_inset


\end_layout

\begin_layout Plain Layout
with the boundary condition of 
\begin_inset Formula $w\left(t_{r}\left(p\right)\right)=\log\left(u_{p}\right)$
\end_inset

 for 
\begin_inset Formula $p=\left\{ 0,1,\ldots,P\right\} $
\end_inset

 where 
\begin_inset Formula $u_{p}$
\end_inset

 are i.i.d.
 random variables uniformly extracted from the interval 
\begin_inset Formula $[0,1]$
\end_inset

.
 Note that 
\begin_inset Formula $\log\left(u_{p}\right)\leq0$
\end_inset

 and 
\begin_inset Formula $\lambda_{k}\left(x\right)\geq0$
\end_inset

 and so starting from the time 
\begin_inset Formula $t=t_{r}\left(p\right)$
\end_inset

 the state 
\begin_inset Formula $w\left(t\right)$
\end_inset

 will monotonically increase until either 
\begin_inset Formula $t=t_{1}$
\end_inset

 if 
\begin_inset Formula $p=P$
\end_inset

 or if 
\begin_inset Formula $p<P$
\end_inset

 until the next reaction occurs at 
\begin_inset Formula $t=t_{r}\left(p+1\right)$
\end_inset

.
 It follows from the random-time-change formulation that 
\begin_inset Formula $\lim_{t\rightarrow t_{r}\left(p+1\right)}w\left(t\right)=0$
\end_inset

.
 Thus by incrementally searching for the roots of 
\begin_inset Formula $w\left(t\right)$
\end_inset

 one can find the time of the reactions in the process of solving the system
 of ODEs.
\begin_inset CommandInset citation
LatexCommand cite
key "kouretas2006stochastic"

\end_inset

 This is called root finding or event detection and modern ODE solvers like
 CVODE support this.
\begin_inset CommandInset citation
LatexCommand cite
key "serban2005cvodes"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The procedure described above is depicted in algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{alg:vanilla_pdmp}
\end_layout

\end_inset

.
 Simulating a PDMP approximation of a SCRN can be considerably faster if
 the reduction of the number of reactions is big enough.
 An improper PDMP approximation can also make the simulation much slower
 than simulating the exact model with SSA.
 This happens for example if there are still a lot of stochastic reactions
 happening and thus the ODE solver has to be started over and over again
 causing a performance hit because the ODE solving machinery has to be reinitial
ized after the state has changed from stochastic reactions.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Vanilla PDMP}
\end_layout

\begin_layout Plain Layout


\backslash
label{alg:vanilla_pdmp}
\end_layout

\begin_layout Plain Layout


\backslash
algblock[evolve]{evolve}{until}
\end_layout

\begin_layout Plain Layout


\backslash
algblockdefx[evolve]{Evolve}{EndEvolve}%
\end_layout

\begin_layout Plain Layout

	{
\backslash
textbf{evolve}}%
\end_layout

\begin_layout Plain Layout

	{
\backslash
textbf{until }}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State $t
\backslash
gets t_0$, $x
\backslash
left(t_0 
\backslash
right)
\backslash
gets x_0$, $p
\backslash
gets 1$
\end_layout

\begin_layout Plain Layout


\backslash
While {$t < t_1$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $u_p 
\backslash
gets
\backslash
 
\backslash
sim 
\backslash
mathcal{U}
\backslash
left[0,1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $w_p
\backslash
left(t 
\backslash
right) 
\backslash
gets 
\backslash
log
\backslash
left(u_p
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	
\backslash
Evolve
\end_layout

\begin_layout Plain Layout

		
\backslash
State $x$ according to $
\backslash
frac{d}{dt}x
\backslash
left(t
\backslash
right) = 
\backslash
sum_{k
\backslash
in M_D} 
\backslash
lambda_k
\backslash
left(x
\backslash
left(t
\backslash
right)
\backslash
right) 
\backslash
left(
\backslash
nu'_k - 
\backslash
nu_k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $w_p$ according to $
\backslash
frac{d}{dt}w_p
\backslash
left(t
\backslash
right) = 
\backslash
sum_{k
\backslash
in M_S} 
\backslash
lambda_k
\backslash
left(x
\backslash
left(t
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndEvolve {$t=t_1$ or $w_p
\backslash
left(t
\backslash
right) = 0$}
\end_layout

\begin_layout Plain Layout

	
\backslash
If {$w_p
\backslash
left(t
\backslash
right) = 0$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $r
\backslash
gets k 
\backslash
mbox{ with probability } p_k
\backslash
propto 
\backslash
lambda_k
\backslash
left(x
\backslash
left(t
\backslash
right)
\backslash
right)$ for $k
\backslash
in
\backslash
left
\backslash
{M_S
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $x
\backslash
left(t
\backslash
right)
\backslash
gets x
\backslash
left(t
\backslash
right) + 
\backslash
nu'_r - 
\backslash
nu_r$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $p 
\backslash
gets p + 1$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Adaptive hybrid models for SCRNs
\end_layout

\begin_layout Standard
The vanilla PDMP algorithm is suitable for SCRNs where a PDMP approximation
 can be found that is both valid over the whole simulation time and that
 considerably reduces the number of reactions that have to be simulated.
 For SCRNs that show big variations in copy-numbers over time this is usually
 not possible.
 Our contribution is an extension of the vanilla PDMP algorithm to accommodate
 for varying scales of the underlying SCRN both in time and in copy numbers.
 The general idea is to define bounds for the copy numbers in a suitable
 manner and upon leaving these bounds a suitable the PDMP approximation
 of the SCRN is updated according to the current time- and copy-number-scales.
\end_layout

\begin_layout Standard
The general outline of our adaptive simulation scheme is shown in algorithm
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{alg:adaptive_pdmp}
\end_layout

\end_inset

.
 In addition to the vanilla PDMP algorithm described above we observe the
 occurence of additional events, i.e.
 the crossing of copy number bounds.
 Of course we also have to perform this check once in a while in the case
 where only stochastic reactions occur.
 If these bounds are crossed we perform an adaptation procedure that will
 compute new values for the scaling parameters 
\begin_inset Formula $\alpha_{i}$
\end_inset

 and 
\begin_inset Formula $\beta_{k}$
\end_inset

, rescale the state-values and possibly perform averaging on suitable subnetwork
s.
 The copy number bounds are defined by parameters 
\begin_inset Formula $\xi\ge0$
\end_inset

 and 
\begin_inset Formula $\eta\ge0$
\end_inset

 (typical values are 
\begin_inset Formula $\xi=1,\eta=0.5$
\end_inset

).
 For a discrete species the upper bound is 
\begin_inset Formula $N_{0}^{\xi}$
\end_inset

.
 For a continuous species the lower and upper bounds are 
\begin_inset Formula $N_{0}^{-\eta}$
\end_inset

 and 
\begin_inset Formula $N_{0}^{\eta}$
\end_inset

 respectively.
 Thus the parameter 
\begin_inset Formula $\xi$
\end_inset

 influences when a species could be considered continuous and the parameter
 
\begin_inset Formula $\eta$
\end_inset

 influences the bound of rescaled copy numbers where no adaptation is performed.
\end_layout

\begin_layout Standard
The adaptation and averaging procedures are described in more detail in
 the following sections.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Adaptive PDMP}
\end_layout

\begin_layout Plain Layout


\backslash
label{alg:adaptive_pdmp}
\end_layout

\begin_layout Plain Layout


\backslash
algblock[evolve]{evolve}{until}
\end_layout

\begin_layout Plain Layout


\backslash
algblockdefx[evolve]{Evolve}{EndEvolve}%
\end_layout

\begin_layout Plain Layout

	{
\backslash
textbf{evolve}}%
\end_layout

\begin_layout Plain Layout

	{
\backslash
textbf{until }}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State $t
\backslash
gets t_0$, $x
\backslash
left(t_0
\backslash
right)
\backslash
gets x_0$, $p
\backslash
gets 1$, $
\backslash
textit{flag}
\backslash
gets 
\backslash
textrm{true}$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
While {$t < t_1$}
\end_layout

\begin_layout Plain Layout

	
\backslash
If {$
\backslash
textit{flag} = 
\backslash
textrm{true}$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $u_p 
\backslash
gets
\backslash
 
\backslash
sim 
\backslash
mathcal{U}
\backslash
left[0,1
\backslash
right]$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $w_p
\backslash
left(t 
\backslash
right) 
\backslash
gets 
\backslash
log
\backslash
left(u_p
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $
\backslash
textit{flag}
\backslash
gets 
\backslash
textrm{false}$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
Evolve
\end_layout

\begin_layout Plain Layout

		
\backslash
State $x$ according to $
\backslash
frac{d}{dt}x
\backslash
left(t
\backslash
right) = 
\backslash
sum_{k=1}^{r_0} 
\backslash
lambda_k
\backslash
left(x
\backslash
left(t
\backslash
right)
\backslash
right) 
\backslash
left(
\backslash
nu'_k - 
\backslash
nu_k
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $w_p$ according to $
\backslash
frac{d}{dt}w_p
\backslash
left(t
\backslash
right) = 
\backslash
sum_{k=1}^{r_0} 
\backslash
lambda_k
\backslash
left(x
\backslash
left(t
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndEvolve {$t=t_1$ or $w_p
\backslash
left(t
\backslash
right) = 0$ or {
\backslash
color{green}
\backslash
textit{copy number bounds have been crossed}}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
color{green}
\end_layout

\begin_layout Plain Layout

	
\backslash
If {
\backslash
textit{copy number bounds have been crossed}}
\end_layout

\begin_layout Plain Layout

		
\backslash
State Perform adaptation procedure
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
color{black}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
If {$w_p
\backslash
left(t
\backslash
right) = 0$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $r
\backslash
gets k 
\backslash
mbox{ with probability } p_k
\backslash
propto 
\backslash
lambda_k
\backslash
left(x
\backslash
left(t
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $x
\backslash
left(t
\backslash
right)
\backslash
gets x
\backslash
left(t
\backslash
right) + 
\backslash
nu'_r - 
\backslash
nu_r$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $p 
\backslash
gets p + 1$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $
\backslash
textit{flag}
\backslash
gets 
\backslash
textrm{true}$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
color{green}
\end_layout

\begin_layout Plain Layout

		
\backslash
If {
\backslash
textit{copy number bounds have been crossed}}
\end_layout

\begin_layout Plain Layout

			
\backslash
State Perform adaptation procedure
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
color{black}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Computation of scaling parameters
\end_layout

\begin_layout Standard
Upon crossing the copy number bounds we want to compute a PDMP approximation
 based on the framework by Kang et al.
 described above.
 To this end we have to make sure that our approximation is well-behaved
 and at the same time we want to handle as many reactions in a deterministic
 way as possible given the current state.
\end_layout

\begin_layout Standard
We achieve this by formulating the 
\shape italic
species balance conditions
\shape default
 as constraints of a linear program that maximizes a weighted sum of the
 
\begin_inset Formula $\alpha_{i}$
\end_inset

 and 
\begin_inset Formula $\beta_{k}$
\end_inset

.
 As the 
\begin_inset Formula $\alpha_{i}$
\end_inset

 will decide whether a reaction term converges to a deterministic term we
 weigh the 
\begin_inset Formula $\alpha_{i}$
\end_inset

 with a factor 
\begin_inset Formula $\lambda$
\end_inset

 that we usually set to 
\begin_inset Formula $100$
\end_inset

.
\end_layout

\begin_layout Standard
Define 
\begin_inset Formula 
\[
A_{i}=\frac{\log(x_{i})}{\log(N_{0})}{\color{green}+1},\ i\in\left\{ 1,\ldots,s_{0}\right\} 
\]

\end_inset


\begin_inset Formula 
\[
B_{k}=\frac{log(\kappa'_{k})}{\log(N_{0})}{\color{green}+1}\ k\in\left\{ 1,\ldots,r_{0}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
We compute the 
\begin_inset Formula $\alpha_{i}$
\end_inset

 and 
\begin_inset Formula $\beta_{k}$
\end_inset

 by solving the following linear program
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula 
\begin{equation}
\begin{array}{ccc}
\mbox{maximize } & \lambda\sum_{i=1}^{s_{0}}\frac{\alpha_{i}}{A_{i}}+\sum_{i=1}^{r_{0}}\frac{\beta_{k}}{B_{k}}\\
\\
\mbox{subject to } & 0\leq\alpha_{i}\leq A_{i} & \mbox{ for each \ensuremath{i\in\left\{ 1,\ldots,s_{0}\right\} }}\\
\mbox{and } & \beta_{k}\leq B_{k} & \mbox{for each }k\in\left\{ 1,\ldots,r_{0}\right\} \\
\mbox{and } & \alpha_{i}\geq\beta_{k}+\alpha\cdot\nu_{k} & \mbox{ for each \ensuremath{i\in\left\{ 1,\ldots,s_{0}\right\} ,\ k\in\left\{ 1,\ldots,r_{0}\right\} }}
\end{array}\label{eq:adaptation_linear_program}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The algorithm for the adaptation procedure is shown in algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{alg:adaptation}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Adaptation}
\end_layout

\begin_layout Plain Layout


\backslash
label{alg:adaptation}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State Compute scaling parameters $
\backslash
alpha_i$ and $
\backslash
beta_k$ by solving the linear program in 
\backslash
ref{eq:adaptation_linear_program}
\end_layout

\begin_layout Plain Layout


\backslash
State Update species and reaction types
\end_layout

\begin_layout Plain Layout


\backslash
State Recompute copy number bounds
\end_layout

\begin_layout Plain Layout


\backslash
State Perform averaging procedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Averaging of fast subnetworks
\end_layout

\begin_layout Standard
After the computation of the scaling parameters in algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{alg:adaptation}
\end_layout

\end_inset

 we perform the averaging of fast subnetworks.
 The possible subnetworks suitable for averaging can be precomputed once
 at the start of the program (e.g.
 weakly reversible, zero-deficiency subnetworks).
 Upon averaging we compute the timescale-separation 
\begin_inset Formula $\Delta\tau$
\end_inset

 of all suitable subnetworks and select the subnetworks with 
\begin_inset Formula $\Delta\tau\geq\zeta$
\end_inset

.
 From these we perform a greedy strategy and repeatedly select the largest
 subnetwork that only contains species that haven't been selected yet.
 This gives us a list of disjunct subnetworks.
 Now we run through the list of subnetworks that were selected for averaging
 in the previous iteration but haven't been selected in the current iteration.
 For each of these subnetworks we sample the state from the stationary distribut
ion.
 Finally we perform averaging by computing the stationary average of each
 selected subnetwork.
\end_layout

\begin_layout Standard
In the case of pseudo-linear subnetworks we simply take the rounded stationary
 average instead of sampling from the stationary distribution as we can't
 compute this for all pseudo-linear subnetworks.
 Similarly in the case of a reducible, weakly reversible, zero-deficiency
 subnetwork we approximate the stationary distribution with a multinomial
 distribution (scaled according to the conservation-relation) as it is very
 difficult to sample from the stationary distribution in the general case.
 We expect that these approximations won't do any harm though one should
 keep them in mind.
\end_layout

\begin_layout Standard
The algorithm for the averaging procedure is shown in algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{alg:averaging}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Averaging}
\end_layout

\begin_layout Plain Layout


\backslash
label{alg:averaging}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
textbf{Once:} Precompute subnetworks $L_A$ suitable for averaging (e.g.
 weakly reversible, zero-deficiency subnetworks)
\end_layout

\begin_layout Plain Layout


\backslash
State Let $L_P$ be the set of previously averaged subnetworks
\end_layout

\begin_layout Plain Layout


\backslash
State Set $L_C = 
\backslash
emptyset$
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {suitable subnetworks $Q 
\backslash
in L_A$}
\end_layout

\begin_layout Plain Layout

	
\backslash
If {$
\backslash
Delta
\backslash
tau
\backslash
left(Q
\backslash
right) 
\backslash
ge 1$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State Set $L_C = L_C 
\backslash
cup {Q}$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State $L_F = 
\backslash
emptyset$
\end_layout

\begin_layout Plain Layout


\backslash
While {$L_C 
\backslash
neq 
\backslash
emptyset$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State Set $Q = 
\backslash
argmax_{W
\backslash
in L_C} 
\backslash
left(|W|
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	
\backslash
State Set $L_C = L_C 
\backslash
setminus {Q}$
\end_layout

\begin_layout Plain Layout

	
\backslash
If {$
\backslash
left
\backslash
{s :
\backslash
  s
\backslash
in W, W
\backslash
in L_F
\backslash
right
\backslash
} 
\backslash
cap {Q} = 
\backslash
emptyset$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State Set $L_F = L_F 
\backslash
cup {Q}$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {subnetwork $Q 
\backslash
in L_P 
\backslash
setminus L_F$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State Sample state for subnetwork $Q$ from the stationary distribution
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
ForAll {subnetwork $Q
\backslash
in L_F$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State Compute stationary average of subnetwork $Q$
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Section
NUMERICAL EXAMPLES
\begin_inset CommandInset label
LatexCommand label
name "sec:NUMERICAL-EXAMPLES"

\end_inset


\end_layout

\begin_layout Section
CONCLUSIONS
\begin_inset CommandInset label
LatexCommand label
name "sec:CONCLUSIONS"

\end_inset


\end_layout

\begin_layout Section*
APPENDIX
\begin_inset CommandInset label
LatexCommand label
name "sec:APPENDIX"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/home/bhepp/Documents/papers"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
